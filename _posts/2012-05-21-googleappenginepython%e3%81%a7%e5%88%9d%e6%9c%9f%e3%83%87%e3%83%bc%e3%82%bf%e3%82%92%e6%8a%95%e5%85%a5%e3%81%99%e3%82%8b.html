---
layout: post
title: GoogleAppEngine/Pythonで初期データを投入する
categories:
- Python
tags:
- GAE/P
- googpe app engine
- model
- pythonmdjango
status: publish
type: post
published: true
meta:
  _edit_last: '2'
author:
  login: yokoshima
  email: k.yokoshima@gmail.com
  display_name: yokoshima
  first_name: ''
  last_name: ''
---
<p>GoogleAppEngineを使うとき、一番最初に投入しておきたいデータを準備する話です。</p>
<p>普通のRDBを使う場合は最悪create文とinsert文を流せば良いのですが、GAEを使う場合は普通、AppEngineのデータストアを使う必要があります。<br />
ですが、AppEngineのデータストアはコンソールでコマンドを流して使えるようなところがないので、<br />
なんとかAPI等を駆使してデータを投入するしかないのですが、Pythonの知識不足も手伝ってすごい長い期間ハマったような気がします。<br />
しかも、特に今の時点では情報が新旧入り交じって情報が錯綜しているので、その歴史の一部分として記述しておきたいと思います。</p>
<p>Google App Engineのバージョンは</p>
<pre>
# cat /usr/local/google_appengine/VERSION 
release: "1.6.5"
timestamp: 1332880663
api_versions: ['1']
</pre>
<p>です。</p>
<h3>Model</h3>
<p>GAEでdjangoを使うこと前提でやっていますが、GAE/Pなら同じ話ではあると思います。<br />
誰かが「RDB脳」という表現をされていましたが、まさにそのとおり。自分の場合は完全RDB脳です。<br />
ただし、GAEで使うのは「データベース」ではなく「データストア」だというところを意識する必要があります。<br />
SQLみたいな操作言語はありますがリレーションも出来ないし、スキーマを定義するのにDDLを作成する必要もないのです。<br />
決めるのは、データを入れる入れ物である「モデル」をソースコードに定義します。</p>
<p>やりようですが、基本はEclipseで何かと操作できるようにやる方法ですが、コンソールも併用します。<br />
ていうか、今回に限ってはEclipseはワークスペースの場所だけの話です。</p>
<p>例が貧弱で申し訳ないですが、例えば商品の情報を格納するモデルを定義するとしますと下記のような感じになります。</p>
<pre lang="python">
from google.appengine.ext import db

class Product(db.Model):
    code = db.StringProperty(required=True)
    name = db.StringProperty(required=True)
    price = db.IntegerProperty()

</pre>
<p>このdb.Modelの型（プロパティ）は下記に詳細があります。<br />
型とプロパティ クラス - Google App Engine — Google Developers<br />
<a href="https://developers.google.com/appengine/docs/python/datastore/typesandpropertyclasses?hl=ja">https://developers.google.com/appengine/docs/python/datastore/typesandpropertyclasses?hl=ja</a></p>
<p>o O ◯ (RatingがあるならCurrencyPropertyとかあっても良いのに…)<br />
とにかくデータの定義はこのモデルでしかやらないです。djgnaoであれば、Models.pyにこれをすべて書いておく感じで定義しておくのでしょう。</p>
<h3>bulkloader</h3>
<p>さてそして、特にアプリ初期化同時に用意しておきたいデータがマスタデータのような場合、かつ量がそこそこな場合には、<br />
その初期データを準備するのをどうするかという問題があります。<br />
作成したモデルクラスにハードコードする手もあります。下記のようにしておくととりあえずデータの投入は出来ます。</p>
<p>Models.py</p>
<pre lang="python">
from google.appengine.ext import db

class Product(db.Model):
    code = db.StringProperty(required=True)
    name = db.StringProperty(required=True)
    price = db.IntegerProperty()

p = Product(code=u"0", name=u"商品１", price=0)
p.put()
</pre>
<p>よく理解していないけど、これはおそらくリクエスト毎に発生する処理になると思うので、<br />
やるならどこか初期化処理で一度延々とModel.put処理を行えば良いのかもしれません、<br />
また、さらによく理解できていないのが主キーの話です。どうも、GAEのモデルは内部的に__key__のようなプロパティを持っていて<br />
それでデータを操作しているようなのですが、そこら辺は今のところよくわかってない。（今後究明予定）</p>
<p>これはマスタデータとしては全然使いものにならないので、CSVファイル等からインポートができるbulkloaderという機能があるそうなのでｓ，<br />
それを使って見ることにしました。<br />
bulkloaderについてのマニュアルは下記にあります。</p>
<p>データのアップロードとダウンロード - Google App Engine — Google Developers<br />
<a href="https://developers.google.com/appengine/docs/python/tools/uploadingdata?hl=ja">https://developers.google.com/appengine/docs/python/tools/uploadingdata?hl=ja</a></p>
<p>bulkloaderを使うでもなんでもそうなのですが、今現状のアプリとの立ち位置を理解しておく必要があります。<br />
bulkloaderは、アプリのModelは使います。あと、そのモデル情報をアップロードするURLがどこなのかが必要な情報とします。<br />
しかし、bulkloader自体は単体で動くので、通常のアプリケーションフォルダではなく「bulkloader」のようなフォルダを作って、<br />
そこで色々操作する方が良いでしょう。ログとかよくわからないSQLiteかなんかのファイルがガンガン作られていき見通しが悪くなるので。</p>
<p>今回やってみるのは、[Eclipseのワークスペース]-[アプリケーションフォルダ]-[bulkloader]のような感じでフォルダを作ってやっています。<br />
この「bulkloader」フォルダ内に、「アプリケーションフォルダ」に配置しているModels.pyのシンボリックリンクを貼って同期を取ります。<br />
bulkloaderフォルダにcdして</p>
<pre lang="bash">
# ln -s ../models.py models.py 
</pre>
<p>としておきます。</p>
<p>さらに、アプリのapp.yamlには下記の記述を追記します。</p>
<pre lang="yaml">
builtins: 
- remote_api: on
</pre>
<p>これが一体何やっているのかがよくわからなかったのですが、どうもbulkloaderのhttpアクセス先を使えるようにしているんじゃないかという説が濃厚です、なのでこれは必須。<br />
ちなみに、このように手探りでやる時に便利だったのが、datastore_adminというbuiltinがあるので、ここはついでにこうしておきましょう。</p>
<pre lang="yaml">
builtins: 
- remote_api: on
- datastore_admin: on
</pre>
<p>これで、作成したモデルのデータを全消しとか出来ます。/_ah/datastore_admin/でアクセスして使います。</p>
<p>この状態、というか前述の商品モデルがあって、そこそこのViewとかがあってそれを取得して表示する位のレベルまで作成したアプリがあるとします。<br />
bulkloaderを使うには、buikloaderの定義ファイルが必要なのですが、そのテンプレートを現状のデータストアから推測して作成してくれるコマンドが書きです。</p>
<pre lang="bash">
# appcfg.py create_bulkloader_config --filename=bulkloader.yaml ../
</pre>
<p>最後の引数は、今bulkloader/にいるので、その直上のアプリケーションフォルダをしている図です。<br />
これでbulkloader.yamlというファイルが色々空気を読んで完璧に作ってくれるはずだったのですが、<br />
どうもエンティティの情報が全然出てない。下記のようなファイルがbulkloader.yamlに出ています。</p>
<pre lang="yaml">
# Autogenerated bulkloader.yaml file.
# You must edit this file before using it. TODO: Remove this line when done.
# At a minimum address the items marked with TODO:
#  * Fill in connector and connector_options
#  * Review the property_map.
#    - Ensure the 'external_name' matches the name of your CSV column,
#      XML tag, etc.
#    - Check that __key__ property is what you want. Its value will become
#      the key name on import, and on export the value will be the Key
#      object.  If you would like automatic key generation on import and
#      omitting the key on export, you can remove the entire __key__
#      property from the property map.

# If you have module(s) with your model classes, add them here. Also
# change the kind properties to model_class.
python_preamble:
- import: base64
- import: re
- import: google.appengine.ext.bulkload.transform
- import: google.appengine.ext.bulkload.bulkloader_wizard
- import: google.appengine.ext.db
- import: google.appengine.api.datastore
- import: google.appengine.api.users

transformers:
</pre>
<p>つまり、transformersより下が全然ないのです。これは最後の引数をディレクトリではなく、--url=http://localhost:8080/_ah/remote_apiとか、appsoot.comの本番サーバーにあげてそのURLを指定してやってみたのですが変わりないようでした。adminのxsrfのデータがエクスポート出来てたようではありますがそんなの全く要らない。</p>
<p>で、色々見たのですが、Modelは作成しただけでは全然影響がなくって、とりえあずModel.putした時点からデータストアと認識されるとかなんとかという話を発見しました（どこだったか。。。）<br />
なので、Modelクラスの最後でテスト的なデータを作ってputしてみたら管理コンソールには現れてきたようでした。<br />
あ、管理コンソールというのは、開発サーバーでいえば、localhost:8080/_ah/adminでアクセス出来る機能です。<br />
データがあればそれを変な感じで表示・変種ができる機能です。<br />
しかし、これを作ったあとにcreate_bulkloader_configをやってみ同じ結果だったので、<br />
bulkloader.yamlを手作業で変更する方がこりゃ早いなと思いやってみました。</p>
<h3>bulkloader.yamlの編集</h3>
<p>例えばいま現在でインポートしたいのは、「Product」というモデルだとします。<br />
これらのデータは、product.csvファイルに下記のような形で、bulkloader/product.csvでおいてあるとします。</p>
<pre lang"csv">
cd,name,price
1,商品1,1000
2,商品2,3000
3,商品3,5000
4,商品4,10000
</pre>
<p>この場合、transformers:以下にこう書けば良い</p>
<pre lang="yaml">
transformers:
- kind: Product
  connector: csv
  connector_options: 
  property_map: 
  - property: code
    external_name: code
    import_transform: int
  - property: name
    external_name: name
  - property: price
    external_name: price
    import_transform: int
</pre>
<p>これの肝は、int型のフィールドの変換を指定しておくこと。<br />
例えば、priceのimport_transformにはintとか書いてあるが、内部ではint(str)が実行されるようです。<br />
これを何もせずにいると、string型でデータが入ってしまいます。<br />
いや、データが入ってしまってもそう問題ないかなと思っていたのですが、そのあとdjangoのテンプレートでforループする時に取り出した型が違うとエラーになった問題があったので、型は揃えときたいとこです。（というかなんで型がそろってないのか）<br />
モデルクラスではInterger型の予定だったのですが、bulkloaderでのロード時に、何も指定しないとString型になってしまうようでした。</p>
<p>これで下記のコマンドを打ちます。<br />
なんかローカルでもイケてるようなきがするのだけど、ローカルで更新する前にappspotでメタデータを更新されているからいけるのかもしれん。</p>
<pre lang="bash">
appcfg.py upload_data --config_file=bulkloader.yaml --kind=Product --filename=product.csv --url=http://localhost:8080/_ah/remote_api
</pre>
<p>あと気になった点では、まずモデルに文字列を入れる場合には、かならず「”あああ”」はじゃなくて「u"あああ"」でやること。<br />
iOSで「@"あああ"」でやってるようなおまじないです。<br />
Integer型とかのtransformでは「int」とか指定してあげる事。（Python表示の関数でint()とかいうのがあるらしいよ）<br />
グダグダ感満載ですがbulkloaderでまとめると</p>
<p>・builloader.yamlのtransformersの項目はとりえあず書けるようにしておいたほうが良い<br />
・app.yamlのbuiltinsでremote_apiとdatastore_adminは有効にしておいたほうがいい</p>
<p>あとやってないのは主キー的な問題だけど、それはまたいつか。<br />
データ投入したら、今度はgqlをちょっと勉強する必要があった。（likeが出来ないので）</p>
<p>ていか、Pythonってちょっと大雑把な感じだなぁ。このブログもAndroidネタとかphpネタならPVがそこそこ稼げるのにPython系は少ない。<br />
何ヶ月後かにはRails/helokuの話をする予定です。</p>
