---
layout: post
title: "シフト演算の右オペランドの制限"
categories:
- "開発"
tags:
- Java
- LogicalOperation
status: publish
type: post
published: true
meta:
  _edit_last: '3'
author:
  login: yokoshima
  email: k.yokoshima@gmail.com
  display_name: yokoshima
  first_name: ''
  last_name: ''
---
<p>シフト演算の右側の値には、int型であれが32ビット以上の値、<br />
long型であれば64ビット以上の値は指定しても無駄になる。<br />
符号ビットを考えれば、int型で表せるのは31ビットまでで、<br />
long型なら63ビットまでである。</p>
<p>当たり前だが、int型で以下のようにシフトしたら0になる。</p>
<pre lang="java" escaped="true">System.out.println(
	Integer.toBinaryString(2147483647) + "(2147483647) &gt;&gt; 31"
	+ " = "  + Integer.toBinaryString(2147483647 &gt;&gt; 31)
	+ "(" + (2147483647 &gt;&gt; 31) + ")"
);
//結果
1111111111111111111111111111111(2147483647) &gt;&gt; 31 = 0(0)</pre>
<p>左シフトした場合は符号を残して左シフトしているが、算術シフトの場合は符号を引き継ぐのではなかったか？</p>
<pre lang="java" escaped="true">System.out.println(
		Integer.toBinaryString(2147483647) + "(2147483647) &lt;&lt; 31"
		+ " = "  + Integer.toBinaryString(2147483647 &lt;&lt; 31)
		+ "(" + (2147483647 &lt;&lt; 31) + ")"
);
//結果
1111111111111111111111111111111(2147483647) &lt;&lt; 31
          = 10000000000000000000000000000000(-2147483648)</pre>
<p>NOTと同じ結果だなぁ。なぜ？</p>
<p>さらにマイナス値を右オペランドに指定した場合だが、まず<a href="http://www.y-adagio.com/public/standards/tr_javalang/15.doc.htm#5122">Java言語規定</a><br />
のシフト演算子の項によると、</p>
<blockquote><p>左辺オぺランドの昇格した型が int ならば，右辺オぺランドの下位5ビットだけをシフト幅として使用する。それは，右辺オペランドが，マスク値 0x1f を用いたビット単位のAND演算子 &amp; (15.21.1) に従うかのようとする。したがって実際に使用するシフト幅は， 0 から 31 までの範囲とする。</p>
<p>左辺オぺランドを昇格した型が long ならば，右辺オぺランドの下位6ビットだけをシフト幅として使用する。それは，右辺オペランドが，マスク値 0x3fを用いたビット単位のAND演算子 &amp; (15.21.1) に従うかのようとする。したがって実際に使用するシフト幅は， 0 から 63 までの範囲とする。</p></blockquote>
<p>と記載がある。intなら2進数で11111(31)、longなら2進数で111111(63)でマスクされる。つまりANDということは<br />
比較元と比較先がどちらも1じゃないと真とならないため、それ以内で1の桁、またそれ以上の値は無効になります。<br />
シフト幅10ビットの場合（9ビット以上は省略）<br />
00001010 ←10進数で10<br />
00011111 ←マスク値(31)<br />
---------<br />
00001010 ←10</p>
<p>シフト幅42ビットの場合<br />
00101010 ←10進数で42<br />
00011111 ←マスク値(31)<br />
---------<br />
00001010 ←10</p>
<p>マイナス値の場合にも法則はあるようで、<br />
例えば<br />
シフト幅-1ビットの場合は2進数だと32桁全て1なので、下位五桁は31になります。<br />
11111111 11111111 11111111 11111111←10進数で-1<br />
00000000 00000000 00000000 00011111←マスク値(31)<br />
---------------------------------------<br />
00000000 00000000 00000000 00011111←結果(31)<br />
-5の場合<br />
11111111 11111111 11111111 11111011←-5<br />
00000000 00000000 00000000 00011111←マスク値(31)<br />
---------------------------------------<br />
00000000 00000000 00000000 00011011←結果(27)<br />
-10の場合<br />
11111111 11111111 11111111 11110110←-10<br />
00000000 00000000 00000000 00011111←マスク値(31)<br />
---------------------------------------<br />
00000000 00000000 00000000 00010110←結果(22)<br />
-30の場合<br />
11111111 11111111 11111111 11100010←-30<br />
00000000 00000000 00000000 00011111←マスク値(31)<br />
---------------------------------------<br />
00000000 00000000 00000000 00000010←結果(2)<br />
-32の場合<br />
11111111 11111111 11111111 11100000←-32<br />
00000000 00000000 00000000 00011111←マスク値(31)<br />
---------------------------------------<br />
00000000 00000000 00000000 00000000←結果(0)<br />
-35の場合<br />
11111111 11111111 11111111 11011101←35<br />
00000000 00000000 00000000 00011111←マスク値(31)<br />
---------------------------------------<br />
00000000 00000000 00000000 00011101←結果(29)</p>
<p>実際にシフト演算してみると</p>
<pre lang="java" escaped="true">//左シフト
System.out.println(
		Integer.toBinaryString(2147483647) + "(2147483647) &lt;&lt; -1"
		+ " = "  + Integer.toBinaryString(2147483647 &lt;&lt; -1)
		+ "(" + (2147483647 &lt;&lt; -1) + ")"
);
System.out.println(
		Integer.toBinaryString(2147483647) + "(2147483647) &lt;&lt; -5"
		+ " = "  + Integer.toBinaryString(2147483647 &lt;&lt; -5)
		+ "(" + (2147483647 &lt;&lt; -5) + ")"
);
System.out.println(
		Integer.toBinaryString(2147483647) + "(2147483647) &lt;&lt; -10"
		+ " = "  + Integer.toBinaryString(2147483647 &lt;&lt; -10)
		+ "(" + (2147483647 &lt;&lt; -10) + ")"
);
//右算術シフト
System.out.println(
		Integer.toBinaryString(2147483647) + "(2147483647) &gt;&gt; -1"
		+ " = "  + Integer.toBinaryString(2147483647 &gt;&gt; -1)
		+ "(" + (2147483647 &gt;&gt; -1) + ")"
);
System.out.println(
		Integer.toBinaryString(2147483647) + "(2147483647) &gt;&gt; -5"
		+ " = "  + Integer.toBinaryString(2147483647 &gt;&gt; -5)
		+ "(" + (2147483647 &gt;&gt; -5) + ")"
);
System.out.println(
		Integer.toBinaryString(2147483647) + "(2147483647) &gt;&gt; -10"
		+ " = "  + Integer.toBinaryString(2147483647 &gt;&gt; -10)
		+ "(" + (2147483647 &gt;&gt; -10) + ")"
);
//右論理シフト
System.out.println(
		Integer.toBinaryString(2147483647) + "(2147483647) &gt;&gt;&gt; -1"
		+ " = "  + Integer.toBinaryString(2147483647 &gt;&gt;&gt; -1)
		+ "(" + (2147483647 &gt;&gt;&gt; -1) + ")"
);
System.out.println(
		Integer.toBinaryString(2147483647) + "(2147483647) &gt;&gt;&gt; -5"
		+ " = "  + Integer.toBinaryString(2147483647 &gt;&gt; -5)
		+ "(" + (2147483647 &gt;&gt;&gt; -5) + ")"
);
System.out.println(
		Integer.toBinaryString(2147483647) + "(2147483647) &gt;&gt;&gt; -10"
		+ " = "  + Integer.toBinaryString(2147483647 &gt;&gt;&gt; -10)
		+ "(" + (2147483647 &gt;&gt;&gt; -10) + ")"
);
//結果
1111111111111111111111111111111(2147483647) &lt;&lt; -1
       = 10000000000000000000000000000000(-2147483648)
1111111111111111111111111111111(2147483647) &lt;&lt; -5
       = 11111000000000000000000000000000(-134217728)
1111111111111111111111111111111(2147483647) &lt;&gt; -1 = 0(0)
1111111111111111111111111111111(2147483647) &gt;&gt; -5 = 1111(15)
1111111111111111111111111111111(2147483647) &gt;&gt; -10 = 111111111(511)
1111111111111111111111111111111(2147483647) &gt;&gt;&gt; -1 = 0(0)
1111111111111111111111111111111(2147483647) &gt;&gt;&gt; -5 = 1111(15)
1111111111111111111111111111111(2147483647) &gt;&gt;&gt; -10 = 111111111(511)</pre>
<p>右オペランドがマイナス値の場合にも法則性がありそうだけど正直使わなさそうなのでここまで。</p>
